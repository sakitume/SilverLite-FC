{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About SilverLite flight controller firmware is a derivative of Silverware . Rather than forking the BWhoop Silverware version (from Silver13/SilverXXX) or NFE Silverware (from Travis Shrock) I instead chose to fork SilF4ware (an STM32F4 port of Silverware from Markus Gritsch) and build up a set of features and extensions on top of that. If you're not already familiar with it, SilF4ware is an amazing port of Silverware with some rather impressive features! I'm awed by this video shared by Markus having \"3D Fun with SilF4ware\" . I had not realized quadcopter flight like this was possible, or was even being performed. Prepare to be amazed when you click on that link. Note: SilverLite flight controller is my own custom spin of Silverware that is heavily based on the very hard work of some extremely talented people. Among them are Markus Gritsch (SilF4ware) , Travis Schrock (NFE Silverware) , Silver13/SilverXXX (Silverware) and of course so many others. My understanding of the history of Silverware is still limited and I'm sure there are numerous other contributors that should be named here as well. Kudos to all of you and thank you again for sharing and contributing so much to this wonderful hobby. SilverLite flight controller firmware was developed for my particular use case : controlling 65mm or 75mm whoops and 2.5\" and 3\" micro quadcopters as well as for the sheer fun of experimenting and hacking. I don't intend it to be much more than that. NotFastEnuf has been developing (the hopefully soon to be released) QuickSilver firmware (the next iteration of his NFE Silverware ); I suspect it will have some really cool features when it comes out. And of course Markus' SilF4ware is an amazing Silverware derivative that has RPM filtering, blackbox logging, enhanced DSHOT implementations, etc. Please check out those other projects. SilverLite features include: A minimal OSD IBUS support Bayang protocol using an external transceiver (NRF24L01, XN297, XN297L). Low latency, theoretical 2ms (or 3ms depending on transmitter), or 5ms if using telemetry. SPI AFHDS and AFHDS2A support (only when building for MATEKF411RX target). Enhanced telemetry and configuration if using my SilverLite Firmware for the FlySky FS-i6 or my SilverLite TX firmware for STM32, ESP32, ESP8266 (unreleased). Quick Start The navigation bar on the left provides a list of topics you'll likely be interested in. It is suggested you read these sections: Configuration This describes what files to edit and what options/features are available to customize. Targets This describes what flight controller targets are supported as well as providing details on flight controller boards known to work with SilverLite. Transceiver modules This describes the available transceiver modules that can be used with SilverLite (XN297, XN297L, LT8900 and NRF24L01) Build and Flash This describes how to build the firmware and also how to flash it onto your flight controller board. Development Tools Setup This describes the software needed for building and flashing SilverLite with a Mac, Windows or Linux PC","title":"Home"},{"location":"#about","text":"SilverLite flight controller firmware is a derivative of Silverware . Rather than forking the BWhoop Silverware version (from Silver13/SilverXXX) or NFE Silverware (from Travis Shrock) I instead chose to fork SilF4ware (an STM32F4 port of Silverware from Markus Gritsch) and build up a set of features and extensions on top of that. If you're not already familiar with it, SilF4ware is an amazing port of Silverware with some rather impressive features! I'm awed by this video shared by Markus having \"3D Fun with SilF4ware\" . I had not realized quadcopter flight like this was possible, or was even being performed. Prepare to be amazed when you click on that link. Note: SilverLite flight controller is my own custom spin of Silverware that is heavily based on the very hard work of some extremely talented people. Among them are Markus Gritsch (SilF4ware) , Travis Schrock (NFE Silverware) , Silver13/SilverXXX (Silverware) and of course so many others. My understanding of the history of Silverware is still limited and I'm sure there are numerous other contributors that should be named here as well. Kudos to all of you and thank you again for sharing and contributing so much to this wonderful hobby. SilverLite flight controller firmware was developed for my particular use case : controlling 65mm or 75mm whoops and 2.5\" and 3\" micro quadcopters as well as for the sheer fun of experimenting and hacking. I don't intend it to be much more than that. NotFastEnuf has been developing (the hopefully soon to be released) QuickSilver firmware (the next iteration of his NFE Silverware ); I suspect it will have some really cool features when it comes out. And of course Markus' SilF4ware is an amazing Silverware derivative that has RPM filtering, blackbox logging, enhanced DSHOT implementations, etc. Please check out those other projects. SilverLite features include: A minimal OSD IBUS support Bayang protocol using an external transceiver (NRF24L01, XN297, XN297L). Low latency, theoretical 2ms (or 3ms depending on transmitter), or 5ms if using telemetry. SPI AFHDS and AFHDS2A support (only when building for MATEKF411RX target). Enhanced telemetry and configuration if using my SilverLite Firmware for the FlySky FS-i6 or my SilverLite TX firmware for STM32, ESP32, ESP8266 (unreleased).","title":"About"},{"location":"#quick-start","text":"The navigation bar on the left provides a list of topics you'll likely be interested in. It is suggested you read these sections: Configuration This describes what files to edit and what options/features are available to customize. Targets This describes what flight controller targets are supported as well as providing details on flight controller boards known to work with SilverLite. Transceiver modules This describes the available transceiver modules that can be used with SilverLite (XN297, XN297L, LT8900 and NRF24L01) Build and Flash This describes how to build the firmware and also how to flash it onto your flight controller board. Development Tools Setup This describes the software needed for building and flashing SilverLite with a Mac, Windows or Linux PC","title":"Quick Start"},{"location":"Configuration/","text":"Hardware Configuration Before building and flashing the firmware you must review and possibly adjust the hardware configuration. Here is a short checklist of things to consider: What flight controller board will you be using? Several boards are supported. What type of receiver will you be using? On-board SPI AFHDS/AFHDS2A is available when using the \"HappyModel Crazybee F4 Lite 1S\" flight controller (found on the Mobula6). This is a MATEKF411RX target board. External SPI Bayang is available using various transceiver modules. . I've had great success with the Play F4 board and an NRF24L01 . Configure your aux channels: throttle kill switch (similar to an arm switch), level mode enable/disable, motor beeps, etc Will you be using RPM filtering? If so, you'll want to make sure your ESCs are flashed with The default configuration is for using the \"JHEMCU Play F4\" (or sometimes named \"JMT Play F4\") whoop sized flight controller coupled to an NRF24L01 transceiver module. RPM filtering is enabled (which requires flashing the onboard ESCs with bidirectional DSHOT support using either JESC or JazzMaverick . The RPM filtering configuration also expects your motors to have 12 poles (as I use 0802 motors). Most small motors for whoop or micros (08XX, 11XX, 12XX) tend to have 12 poles. The above configuration is what I typically use but by adjusting various configuration files you should be able to customize SilverLite to match your needs. Only three flight controller targets are currently supported ( MATEKF411RX , NOX , OMNIBUSF4 ). The MATEKF411RX target can support an on-board SPI transceiver (only FlySky AFHDS/AFHDS2A is supported at this time). If you wish to use an external SPI RX transceiver 4 different modules are supported. Lastly, IBUS support is available; I've successfully used the FlySky FS-RX2A receiver with IBUS on the NOX and OMNIBUSF4 targets. The Play F4 board is a NOX flight controller target. There are enough pads on this FC board to support a few different ways to wire it up to an NRF24L01 (or XN297 etc). I've tried at least two different wiring configurations as well as a few different locations and orientations to mount the board. If you want to do something different than the default there should be enough information in this document to help you figure it out. If not, please open an issue on my github project page so I can help. At a minimum the following two files should be carefully reviewed and edited to meet your custom needs: _myConfig.h Defines for: RX implementation to use, rates (acro and level mode), expo curves, PID terms, looptime, RPM filter enable/disable, low pass filters, TX switches/channels, gyro (board) orientation, motor order, sticks deadband _myHardware.h Defines for: DSHOT configuration, idle offest, motor pole count. Default config is DSHOT300, 12 pole motors, I've structured and commented these header files so that it should hopefully be self explanatory when it comes to enabling and configuring the features. If you choose an SPI RX implementation which uses an external transceiver module (NRF24L01, XN297, LT8900, etc) you may also need to review and edit this file: trx_spi_config.h Used to define which STM32 pins to use for software SPI implementation. In other words what pads on your flight controller board will be wired up to the pads on the the transceiver module board. Advanced configuration This is just a placeholder for now. I hope to provide more details on how to configure various features. A lot of useful info can be found on Markus's thread regarding his SilF4ware firmware. Motor order: https://www.rcgroups.com/forums/showpost.php?p=41995581 postcount=341","title":"Configuration"},{"location":"Configuration/#hardware-configuration","text":"Before building and flashing the firmware you must review and possibly adjust the hardware configuration. Here is a short checklist of things to consider: What flight controller board will you be using? Several boards are supported. What type of receiver will you be using? On-board SPI AFHDS/AFHDS2A is available when using the \"HappyModel Crazybee F4 Lite 1S\" flight controller (found on the Mobula6). This is a MATEKF411RX target board. External SPI Bayang is available using various transceiver modules. . I've had great success with the Play F4 board and an NRF24L01 . Configure your aux channels: throttle kill switch (similar to an arm switch), level mode enable/disable, motor beeps, etc Will you be using RPM filtering? If so, you'll want to make sure your ESCs are flashed with The default configuration is for using the \"JHEMCU Play F4\" (or sometimes named \"JMT Play F4\") whoop sized flight controller coupled to an NRF24L01 transceiver module. RPM filtering is enabled (which requires flashing the onboard ESCs with bidirectional DSHOT support using either JESC or JazzMaverick . The RPM filtering configuration also expects your motors to have 12 poles (as I use 0802 motors). Most small motors for whoop or micros (08XX, 11XX, 12XX) tend to have 12 poles. The above configuration is what I typically use but by adjusting various configuration files you should be able to customize SilverLite to match your needs. Only three flight controller targets are currently supported ( MATEKF411RX , NOX , OMNIBUSF4 ). The MATEKF411RX target can support an on-board SPI transceiver (only FlySky AFHDS/AFHDS2A is supported at this time). If you wish to use an external SPI RX transceiver 4 different modules are supported. Lastly, IBUS support is available; I've successfully used the FlySky FS-RX2A receiver with IBUS on the NOX and OMNIBUSF4 targets. The Play F4 board is a NOX flight controller target. There are enough pads on this FC board to support a few different ways to wire it up to an NRF24L01 (or XN297 etc). I've tried at least two different wiring configurations as well as a few different locations and orientations to mount the board. If you want to do something different than the default there should be enough information in this document to help you figure it out. If not, please open an issue on my github project page so I can help. At a minimum the following two files should be carefully reviewed and edited to meet your custom needs: _myConfig.h Defines for: RX implementation to use, rates (acro and level mode), expo curves, PID terms, looptime, RPM filter enable/disable, low pass filters, TX switches/channels, gyro (board) orientation, motor order, sticks deadband _myHardware.h Defines for: DSHOT configuration, idle offest, motor pole count. Default config is DSHOT300, 12 pole motors, I've structured and commented these header files so that it should hopefully be self explanatory when it comes to enabling and configuring the features. If you choose an SPI RX implementation which uses an external transceiver module (NRF24L01, XN297, LT8900, etc) you may also need to review and edit this file: trx_spi_config.h Used to define which STM32 pins to use for software SPI implementation. In other words what pads on your flight controller board will be wired up to the pads on the the transceiver module board.","title":"Hardware Configuration"},{"location":"Configuration/#advanced-configuration","text":"This is just a placeholder for now. I hope to provide more details on how to configure various features. A lot of useful info can be found on Markus's thread regarding his SilF4ware firmware. Motor order: https://www.rcgroups.com/forums/showpost.php?p=41995581 postcount=341","title":"Advanced configuration"},{"location":"Debug_With_STM32CubeIDE/","text":"Run openocd like so: openocd -f interface/stlink.cfg -f target/stm32f4x.cfg Under \"Debug Configurations\", \"Main\" tab: \"Project\" shold be the project you're using For \"C/C++ Application\" obj\\main\\betaflight_OMNIBUSF4.elf . Don't use the \"Browse\" button and select the elf, this results in a full path being specified which will cause a weird error. It needs to be relative to the project and use windows slash characters Also select the \"Disable auto build\" option Under \"Debug Configurations\", \"Debugger\" tab. For \"GDB Command:\" browse and select this file: C:\\Tools\\armcc\\bin\\arm-none-eabi-gdb.exe For \"Remote Target\" tick the \"Use remote target\" checkbox. For \"JTAG Device\" Choose \"ST-Link (OpenOCD)\" The host and port should already be correct: localhost, 3333 Under \"Debug Configurations\", \"Startup\" tab. Uncheck the \"Load image\" box. This just causes problems. Better to use a separate build/flash process for that. -------------- Using this guide: https://github.com/ethanhuanginst/STM32CubeIDE-Workshop-2019/tree/master/hands-on/02_stm32_hp141_lcd Create a new STM32 project Enter STM32F405RG. Then in the \"Project Setup\" dialog be sure to * Name the project \"Betaflight\" * Uncheck \"Use default location\" and then click \"Browse\" and navigate to where you want the project and create a new folder and select it. * Under \"Target Project Type\" be sure to choose \"Empty\" instead of the default \"STM32Cube\". Delete all of the source files (from the Prjoect Explorer). Then in Windows explorer navigate to that folder and you'll see you have these * .settings folder * .cproject file * .project file Copy these three into your Betaflight local repo folder. Then you can double-click the .project file to launch STM32CubeIDe. Right click the \"Betaflight\" project in \"Project Explorer\" and in the popup menu choose \"Properties\". Under \"C/C++ Build\", \"Builder Setttings\" be sure to uncheck the \"Generate Makefiles automatically\" option. For the \"Builder\" section the \"Builder type\" should be \"External Builder\". And uncheck the \"Use default build command\" and in the \"Build command\" input field enter: mingw32-make -j12 specify SHELL=\"C:\\Program Files\\Git\\git-bash.exe\" Using mingw32-make Building Betaflight with mingw32-make. Set ARM_SDK_DIR to the location of your gcc arm toolchain. For me it would be /c/Tools/armcc . mingw32-make -j12 TARGET=NOX ARM_SDK_DIR=/c/Tools/armcc mingw32-make -j12 TARGET=NOX ARM_SDK_DIR=/c/Tools/armcc DEBUG=GDB","title":"Debug With STM32CubeIDE"},{"location":"Debug_With_STM32CubeIDE/#-","text":"Using this guide: https://github.com/ethanhuanginst/STM32CubeIDE-Workshop-2019/tree/master/hands-on/02_stm32_hp141_lcd Create a new STM32 project Enter STM32F405RG. Then in the \"Project Setup\" dialog be sure to * Name the project \"Betaflight\" * Uncheck \"Use default location\" and then click \"Browse\" and navigate to where you want the project and create a new folder and select it. * Under \"Target Project Type\" be sure to choose \"Empty\" instead of the default \"STM32Cube\". Delete all of the source files (from the Prjoect Explorer). Then in Windows explorer navigate to that folder and you'll see you have these * .settings folder * .cproject file * .project file Copy these three into your Betaflight local repo folder. Then you can double-click the .project file to launch STM32CubeIDe. Right click the \"Betaflight\" project in \"Project Explorer\" and in the popup menu choose \"Properties\". Under \"C/C++ Build\", \"Builder Setttings\" be sure to uncheck the \"Generate Makefiles automatically\" option. For the \"Builder\" section the \"Builder type\" should be \"External Builder\". And uncheck the \"Use default build command\" and in the \"Build command\" input field enter: mingw32-make -j12 specify SHELL=\"C:\\Program Files\\Git\\git-bash.exe\"","title":"--------------"},{"location":"Debug_With_STM32CubeIDE/#using-mingw32-make","text":"Building Betaflight with mingw32-make. Set ARM_SDK_DIR to the location of your gcc arm toolchain. For me it would be /c/Tools/armcc . mingw32-make -j12 TARGET=NOX ARM_SDK_DIR=/c/Tools/armcc mingw32-make -j12 TARGET=NOX ARM_SDK_DIR=/c/Tools/armcc DEBUG=GDB","title":"Using mingw32-make"},{"location":"Debugging/","text":"I was able to get STM32CubeIDE to build and debug the project using the information here: https://github.com/ethanhuanginst/STM32CubeIDE-Workshop-2019/blob/master/hands-on/02_stm32_hp141_lcd/README.md","title":"Debugging"},{"location":"DevNotes/","text":"SilverLite TX packets Bind packets are just like normal Bayang bind packets with a few changes. Here is a description of the normal Bayang bind packet: packet[0] - Identifies the bayang subprotocol 0xA4 = Stock Bayang or Silverware with no telemetry 0xA3 = Silverware with telemetry 0xA1 = Silverware with telemetry, with 2 aux analog channels 0xA2 = Silverware no telemetry, with 2 aux analog channels packet[1..5] - The 5 byte address of the TX packet[6..9] - 4 channel values to cycle through when hopping packet[10] - First byte of TX address packet[11] - Second byte of TX address packet[12] - Third byte of TX address packet[13] - 0x0A packet[14] - The checksum of the previous 14 bytes A SilverLite capable transmitter will follow the above format with the exception of the following: packet[10] - First byte of TX address XOR 0xAA packet[11] - Second byte of TX address XOR 0xAA A SilverLite capable receiver will check if these two bytes have this XOR'd value and set a flag if found. This lets the flight controller send back SilverLite telemetry packets and accept custom SilverLite TX packets. \"Normal\" Bayang TX packets containing channel information follow this format: packet[0] - 0xA5 to indicate this is a \"normal\" packet packet[2] For true Bayang: 0xF4 - Use slow rates 0xF7 - Use normal rates 0xFA - Use fast rates For Silverware with aux analog extension aux channel 0. A byte value between 0..255 packet[2] - Bit flags BAYANG_FLAG_RTH = 0x01 BAYANG_FLAG_HEADLESS = 0x02 BAYANG_FLAG_FLIP = 0x08 BAYANG_FLAG_VIDEO = 0x10 BAYANG_FLAG_SNAPSHOT = 0x20 packet[3] - Bit flags BAYANG_FLAG_EMG_STOP = 0x04 BAYANG_FLAG_INVERT = 0x80 BAYANG_FLAG_TAKE_OFF = 0x20 packet[4..5] - A channel packet[6..7] - E channel packet[8..9] - T channel packet[10..11]- R channel packet[12] - Third byte of TX address ( rx_tx_addr[2] ) packet[13] For true Bayang/Silveware: 0x0A For Silverware with aux analog extension aux channel 1. A byte value between 0..255 packet[14] - The checksum of the previous 14 bytes The AETR channel values are each encoded into two bytes as a channel value. Or you could also think of it as a 16bit unsigned integer stored in big-endian format (most signifcant byte first). This unsigned integer value will be in the range 0..1023 requiring only 10 bits. The remaining 5 bits will either be all set or may have some weird value I don't yet understand....something to do with \"dyntrim\" (see Goebish nrf24l01 multiprotocol module or Pascal Langer's multiprotocol module for more information). A SilverLite TX (if configured) will override one byte of the above packet: * packet[12] - Third byte of TX address ( rx_tx_addr[2] ) XOR 0xAA This is used as a signal to the RX that the transmitter is SilverLite capable. This is necessary in case the RX skipped the bind phase completely due to it being previously configured for auto-bind upon startup. If the SilverLite TX has received confirmation from the RX that it too is SilverLite capable (via a special telemetry packet), then the \"normal\" packet can be further modified. * packet[4] - Upper 5 bits only. A command code between 0..31 inclusive * packet[6] - Upper 5 bits only * packet[8] - Upper 5 bits only * packet[2] - Entire byte * packet[12] - Entire byte * packet[13] - Entire byte The command code in packet[4] is used to determine how the other bits and bytes should be used. A better PID tweaking implementation With the standard Silverware aux_analog[] extension, if we want to be able to adjust the I term using an aux_analog[] channel we'd need a third channel which we don't have. If we wanted to adjust Yaw PID terms we'd need even more channels. Also, this extension uses these aux_analog[] values to scale some computations that use the P and D terms; it is not actually modifying the P and D terms themselves. The SilverLite extension uses only a single aux analog channel in conjunction with different command code to modify the PID terms directly. The command mode is sent with each packet as part of the SilverLite extension. kTweakPD_RollPitch aux_analog[0] is used to update pidkp[] and pidkd[] for roll and pitch kTweakI_RollPitch aux_analog[0] is used to update pidki[] for roll and pitch kTweakPD_Yaw aux_analog[0] is used to update pidki[] for yaw kTweakI_Yaw aux_analog[0] is used to update pidki[] for yaw kTweakDisabled aux_analog[] is ignored and pid values are untouched kTweakCalibrate aux_analog[0] value should be recorded and used as a baseline reference. Most importantly, the aux_analog[0] value is not used directly. Instead it's relative change is used to increment or decrement the PID term(s). A baseline should have been set (via the kTweakCalibrate command). This baseline is subtracted from the aux_analog[0] value, scaled (usually by 1.0f) and the final result is added to the PID term being modified. Note: The kTweakCalibrate command is sent a few times in between every mode change so that the new mode will work correctly. STM32 Processors Processor (example chip) Processor Speed no. of UART on FC Flash Memory* F1 (STM32F103CBT6) 72MHz 2 128KB F3 (STM32F303CCT6) 72MHz 3 256KB F4 (STM32F405RGT6) 168MHz 3 1MB F7 (STM32F745VG) 216MHz 8 1MB H7 (STM32H750) 480MHz TBC 128KB","title":"SilverLite TX packets"},{"location":"DevNotes/#silverlite-tx-packets","text":"Bind packets are just like normal Bayang bind packets with a few changes. Here is a description of the normal Bayang bind packet: packet[0] - Identifies the bayang subprotocol 0xA4 = Stock Bayang or Silverware with no telemetry 0xA3 = Silverware with telemetry 0xA1 = Silverware with telemetry, with 2 aux analog channels 0xA2 = Silverware no telemetry, with 2 aux analog channels packet[1..5] - The 5 byte address of the TX packet[6..9] - 4 channel values to cycle through when hopping packet[10] - First byte of TX address packet[11] - Second byte of TX address packet[12] - Third byte of TX address packet[13] - 0x0A packet[14] - The checksum of the previous 14 bytes A SilverLite capable transmitter will follow the above format with the exception of the following: packet[10] - First byte of TX address XOR 0xAA packet[11] - Second byte of TX address XOR 0xAA A SilverLite capable receiver will check if these two bytes have this XOR'd value and set a flag if found. This lets the flight controller send back SilverLite telemetry packets and accept custom SilverLite TX packets. \"Normal\" Bayang TX packets containing channel information follow this format: packet[0] - 0xA5 to indicate this is a \"normal\" packet packet[2] For true Bayang: 0xF4 - Use slow rates 0xF7 - Use normal rates 0xFA - Use fast rates For Silverware with aux analog extension aux channel 0. A byte value between 0..255 packet[2] - Bit flags BAYANG_FLAG_RTH = 0x01 BAYANG_FLAG_HEADLESS = 0x02 BAYANG_FLAG_FLIP = 0x08 BAYANG_FLAG_VIDEO = 0x10 BAYANG_FLAG_SNAPSHOT = 0x20 packet[3] - Bit flags BAYANG_FLAG_EMG_STOP = 0x04 BAYANG_FLAG_INVERT = 0x80 BAYANG_FLAG_TAKE_OFF = 0x20 packet[4..5] - A channel packet[6..7] - E channel packet[8..9] - T channel packet[10..11]- R channel packet[12] - Third byte of TX address ( rx_tx_addr[2] ) packet[13] For true Bayang/Silveware: 0x0A For Silverware with aux analog extension aux channel 1. A byte value between 0..255 packet[14] - The checksum of the previous 14 bytes The AETR channel values are each encoded into two bytes as a channel value. Or you could also think of it as a 16bit unsigned integer stored in big-endian format (most signifcant byte first). This unsigned integer value will be in the range 0..1023 requiring only 10 bits. The remaining 5 bits will either be all set or may have some weird value I don't yet understand....something to do with \"dyntrim\" (see Goebish nrf24l01 multiprotocol module or Pascal Langer's multiprotocol module for more information). A SilverLite TX (if configured) will override one byte of the above packet: * packet[12] - Third byte of TX address ( rx_tx_addr[2] ) XOR 0xAA This is used as a signal to the RX that the transmitter is SilverLite capable. This is necessary in case the RX skipped the bind phase completely due to it being previously configured for auto-bind upon startup. If the SilverLite TX has received confirmation from the RX that it too is SilverLite capable (via a special telemetry packet), then the \"normal\" packet can be further modified. * packet[4] - Upper 5 bits only. A command code between 0..31 inclusive * packet[6] - Upper 5 bits only * packet[8] - Upper 5 bits only * packet[2] - Entire byte * packet[12] - Entire byte * packet[13] - Entire byte The command code in packet[4] is used to determine how the other bits and bytes should be used.","title":"SilverLite TX packets"},{"location":"DevNotes/#a-better-pid-tweaking-implementation","text":"With the standard Silverware aux_analog[] extension, if we want to be able to adjust the I term using an aux_analog[] channel we'd need a third channel which we don't have. If we wanted to adjust Yaw PID terms we'd need even more channels. Also, this extension uses these aux_analog[] values to scale some computations that use the P and D terms; it is not actually modifying the P and D terms themselves. The SilverLite extension uses only a single aux analog channel in conjunction with different command code to modify the PID terms directly. The command mode is sent with each packet as part of the SilverLite extension. kTweakPD_RollPitch aux_analog[0] is used to update pidkp[] and pidkd[] for roll and pitch kTweakI_RollPitch aux_analog[0] is used to update pidki[] for roll and pitch kTweakPD_Yaw aux_analog[0] is used to update pidki[] for yaw kTweakI_Yaw aux_analog[0] is used to update pidki[] for yaw kTweakDisabled aux_analog[] is ignored and pid values are untouched kTweakCalibrate aux_analog[0] value should be recorded and used as a baseline reference. Most importantly, the aux_analog[0] value is not used directly. Instead it's relative change is used to increment or decrement the PID term(s). A baseline should have been set (via the kTweakCalibrate command). This baseline is subtracted from the aux_analog[0] value, scaled (usually by 1.0f) and the final result is added to the PID term being modified. Note: The kTweakCalibrate command is sent a few times in between every mode change so that the new mode will work correctly.","title":"A better PID tweaking implementation"},{"location":"DevNotes/#stm32-processors","text":"Processor (example chip) Processor Speed no. of UART on FC Flash Memory* F1 (STM32F103CBT6) 72MHz 2 128KB F3 (STM32F303CCT6) 72MHz 3 256KB F4 (STM32F405RGT6) 168MHz 3 1MB F7 (STM32F745VG) 216MHz 8 1MB H7 (STM32H750) 480MHz TBC 128KB","title":"STM32 Processors"},{"location":"DevToolsSetup/","text":"Setting up your development environment This page will walk you through the steps of setting up your development environment so that you can build and deploy this project onto your flight controller board. It should be possible to develop on Mac OS, Linux and Windows platforms. This is due to using a variety of open source tools and technologies that are supported on all of these operating systems. Note: The specific examples provided here will often be written from the perspective of using a Windows development PC. I hope to update this document in the future to provide more specific examples for Mac OS and Linux platforms. What we'll need Here are the software tools you'll need: ARM gnu toolchain This is the compiler toolchain we'll use to build the firmware mingw-w64 (if you will be developing under Windows) This is needed solely for the make tool, or more specifically mingw32-make.exe OpenOCD This is only needed if you wish to use an ST-Link adapter to flash your flight controller. STM32CubeProgrammer This is a simple to use flashing tool. It has a GUI interface as well as a command line interface. Visual Studio Code This isn't required but is quite handy to use if you will be editing configuration files or developing code. Installing the tools If you don't already have VScode installed on your machine please visit the following website and follow the install directions: https://code.visualstudio.com/ If you'll be developing code I suggest you also install the C/C++ extensions For the remaining tools I recommend installing them into into a single folder. On my Windows machine I use C:\\Tools . You could also choose to use C:\\VSARM . Keep it simple and avoid having spaces in the path. On a Mac or Linux machine you could create a subfolder in your home folder. mkdir ~/vsarm Install arm gnu toolchain Go to: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads Download the appropriate installer. There are several available. Windows installation For my Windows development PC I chose: gcc-arm-none-eabi-8-2019-q3-update-win32-sha2.exe Windows 32-bit Installer (Signed for Windows 7 and later) MD5: d44f44b258b203bdd6808752907754be Run the installer. When it prompts you to \"Choose Install Location\" I changed the default shown in \"Destination Folder\" from: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\8 2019-q3-update to C:\\Tools\\armcc Make sure these gnu tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\armcc\\bin Mac OS installation For my old MacBook I chose to download this version: Mac OS X 64-bit File: gcc-arm-none-eabi-8-2019-q3-update-mac.tar.bz2 (105.72 MB) Using a Finder window I then double-clicked on the downloaded .bz2 file which unpacked the contents into a new folder named: gcc-arm-none-eabi-8-2019-q3-update I then renamed that folder to armcc and then moved this armcc folder into my ~/vsarm folder. Finally I adjusted my path by editing my .zshrc file and added this to the bottom of it: # vsarm tools export PATH= $HOME/vsarm/armcc/bin:$PATH Note: If you use bash for your shell (which is the default for Mac OS) then add the above to your ~/.bash_profile instead. Install MinGW-W64 (for Windows machines only) This step is only needed for Windows development machines. We need MinGW-W64 for the mingw32-make.exe program. If you have already have a make utility on your machine then you could skip this Go to: https://sourceforge.net/projects/mingw-w64/ Change the install location to: C:\\Tools\\mingw Make sure the MinGW-W64 tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\mingw\\mingw32\\bin Installing OpenOCD on Windows Again, this is only necessary if you wish (and are able) to use the ST-Link adapter. For Windows users I recommend obtaining a version of OpenOCD from here: https://gnutoolchains.com/arm-eabi/openocd/ Download the most recent 7zip file: openocd-20190828.7z Decompress it into C:\\Tools folder. Rename the resultant OpenOCD-20190828-0.10.0 folder to just OpenOCD . Make sure the OpenOCD tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\OpenOCD\\bin Note: There are several binary versions of OpenOCD available for installation. The one from SysProgs (gnutoolchains.com) seems to be updated regularly and also provides drivers that may be helpful to you. Installing OpenOCD on Mac OS While it may be possible to install a prebuilt version of OpenOCD using Homebrew, I've learned that the OpenOCD project maintainers recommend Mac/Linux users to build it themselves using the latest version of the source code available from the repository. We'll use Homebrew to build and install OpenOCD using the latest available source code. Using Terminal, enter the following: brew install open-ocd --HEAD This took a little while to complete, but once it finished I found it was immmediately available for use at /usr/local/bin/openocd . No adjustments to my path were needed. Configure VSCode shell One very important note: The makefile I'm using uses rm -rf as part of building the clean target. This rm command isn't normally available on windows. So I've configured my VSCode environment to use a bash shell whenever it needs to provide a shell for any command. This bash shell came with my Git for Windows installation. If you have something similar, then you'll want to configure VSCode to use such a shell. Alternatively you can edit the makefile(s) in this project folder. To configure VSCode to use a particular shell you need to edit your settings.json file. Details are provided here: https://code.visualstudio.com/docs/editor/integrated-terminal . Basically you need to enter a configuration line like one of the following: // Command Prompt terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\cmd.exe // PowerShell terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe // Git Bash terminal.integrated.shell.windows : C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe // Bash on Ubuntu (on Windows) terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\bash.exe Obviously you should use one of the bash options in the above examples. Personally I prefer the bash from my git install versus the one from my Windows Subsystem for Linux (WSL) since it loads up much faster.","title":"Development Tools Setup"},{"location":"DevToolsSetup/#setting-up-your-development-environment","text":"This page will walk you through the steps of setting up your development environment so that you can build and deploy this project onto your flight controller board. It should be possible to develop on Mac OS, Linux and Windows platforms. This is due to using a variety of open source tools and technologies that are supported on all of these operating systems. Note: The specific examples provided here will often be written from the perspective of using a Windows development PC. I hope to update this document in the future to provide more specific examples for Mac OS and Linux platforms.","title":"Setting up your development environment"},{"location":"DevToolsSetup/#what-well-need","text":"Here are the software tools you'll need: ARM gnu toolchain This is the compiler toolchain we'll use to build the firmware mingw-w64 (if you will be developing under Windows) This is needed solely for the make tool, or more specifically mingw32-make.exe OpenOCD This is only needed if you wish to use an ST-Link adapter to flash your flight controller. STM32CubeProgrammer This is a simple to use flashing tool. It has a GUI interface as well as a command line interface. Visual Studio Code This isn't required but is quite handy to use if you will be editing configuration files or developing code.","title":"What we'll need"},{"location":"DevToolsSetup/#installing-the-tools","text":"If you don't already have VScode installed on your machine please visit the following website and follow the install directions: https://code.visualstudio.com/ If you'll be developing code I suggest you also install the C/C++ extensions For the remaining tools I recommend installing them into into a single folder. On my Windows machine I use C:\\Tools . You could also choose to use C:\\VSARM . Keep it simple and avoid having spaces in the path. On a Mac or Linux machine you could create a subfolder in your home folder. mkdir ~/vsarm","title":"Installing the tools"},{"location":"DevToolsSetup/#install-arm-gnu-toolchain","text":"Go to: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads Download the appropriate installer. There are several available.","title":"Install arm gnu toolchain"},{"location":"DevToolsSetup/#windows-installation","text":"For my Windows development PC I chose: gcc-arm-none-eabi-8-2019-q3-update-win32-sha2.exe Windows 32-bit Installer (Signed for Windows 7 and later) MD5: d44f44b258b203bdd6808752907754be Run the installer. When it prompts you to \"Choose Install Location\" I changed the default shown in \"Destination Folder\" from: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\8 2019-q3-update to C:\\Tools\\armcc Make sure these gnu tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\armcc\\bin","title":"Windows installation"},{"location":"DevToolsSetup/#mac-os-installation","text":"For my old MacBook I chose to download this version: Mac OS X 64-bit File: gcc-arm-none-eabi-8-2019-q3-update-mac.tar.bz2 (105.72 MB) Using a Finder window I then double-clicked on the downloaded .bz2 file which unpacked the contents into a new folder named: gcc-arm-none-eabi-8-2019-q3-update I then renamed that folder to armcc and then moved this armcc folder into my ~/vsarm folder. Finally I adjusted my path by editing my .zshrc file and added this to the bottom of it: # vsarm tools export PATH= $HOME/vsarm/armcc/bin:$PATH Note: If you use bash for your shell (which is the default for Mac OS) then add the above to your ~/.bash_profile instead.","title":"Mac OS installation"},{"location":"DevToolsSetup/#install-mingw-w64-for-windows-machines-only","text":"This step is only needed for Windows development machines. We need MinGW-W64 for the mingw32-make.exe program. If you have already have a make utility on your machine then you could skip this Go to: https://sourceforge.net/projects/mingw-w64/ Change the install location to: C:\\Tools\\mingw Make sure the MinGW-W64 tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\mingw\\mingw32\\bin","title":"Install MinGW-W64 (for Windows machines only)"},{"location":"DevToolsSetup/#installing-openocd-on-windows","text":"Again, this is only necessary if you wish (and are able) to use the ST-Link adapter. For Windows users I recommend obtaining a version of OpenOCD from here: https://gnutoolchains.com/arm-eabi/openocd/ Download the most recent 7zip file: openocd-20190828.7z Decompress it into C:\\Tools folder. Rename the resultant OpenOCD-20190828-0.10.0 folder to just OpenOCD . Make sure the OpenOCD tools are in your path. More specifically you will want to add this to your path: C:\\Tools\\OpenOCD\\bin Note: There are several binary versions of OpenOCD available for installation. The one from SysProgs (gnutoolchains.com) seems to be updated regularly and also provides drivers that may be helpful to you.","title":"Installing OpenOCD on Windows"},{"location":"DevToolsSetup/#installing-openocd-on-mac-os","text":"While it may be possible to install a prebuilt version of OpenOCD using Homebrew, I've learned that the OpenOCD project maintainers recommend Mac/Linux users to build it themselves using the latest version of the source code available from the repository. We'll use Homebrew to build and install OpenOCD using the latest available source code. Using Terminal, enter the following: brew install open-ocd --HEAD This took a little while to complete, but once it finished I found it was immmediately available for use at /usr/local/bin/openocd . No adjustments to my path were needed.","title":"Installing OpenOCD on Mac OS"},{"location":"DevToolsSetup/#configure-vscode-shell","text":"One very important note: The makefile I'm using uses rm -rf as part of building the clean target. This rm command isn't normally available on windows. So I've configured my VSCode environment to use a bash shell whenever it needs to provide a shell for any command. This bash shell came with my Git for Windows installation. If you have something similar, then you'll want to configure VSCode to use such a shell. Alternatively you can edit the makefile(s) in this project folder. To configure VSCode to use a particular shell you need to edit your settings.json file. Details are provided here: https://code.visualstudio.com/docs/editor/integrated-terminal . Basically you need to enter a configuration line like one of the following: // Command Prompt terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\cmd.exe // PowerShell terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe // Git Bash terminal.integrated.shell.windows : C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe // Bash on Ubuntu (on Windows) terminal.integrated.shell.windows : C:\\\\Windows\\\\System32\\\\bash.exe Obviously you should use one of the bash options in the above examples. Personally I prefer the bash from my git install versus the one from my Windows Subsystem for Linux (WSL) since it loads up much faster.","title":"Configure VSCode shell"},{"location":"Develop/","text":"Building Before you can run this firmware onto your flight controller you will need to build it and then flash it onto your board. The easy way to build and flash Use Visual Studio Code as a lightweight development environment. Make sure you've setup the necesary development tools (see the Development Tools Section ). Use the VSCode \"Open Folder\" option with the project folder you cloned from github. I've configured some files (within the .vs folder) to define some \"tasks\" that make it much easier to build and flash. You can click on the \"Run build task\" icon in the status bar... ..or use the Ctrl-Alt-T keyboard combination to bring up the following menu which will let you clean, build and flash for any of the supported targets: Enter DFU mode Before you can flash the firmware the flight controller board must enter DFU mode. Typically you would press a \"BOOT\" button on the FC board (or jump some BOOT pads together) and then power up the flight controller board by plugging in the USB cable. You could also power it up with a battery, but you'll still need to connect the board to your compute via USB. If your board is currently running Betaflight and you can connect to it with the Betaflight configurator, you could instead use the \"CLI\" option in Betaflight and enter bl in the command line to enter \"bootloader\" mode (DFU mode). Once you've entered DFU mode you should be able to flash SilverLite onto your FC board. The monitor.py script This is a handly little Python script I knocked out that listens over the virtual com port (the USB connection). SilverLite periodically sends out a data packet every second that this script can decode and log onto the terminal window. However it can also be used to enter commands by pressing a key on your keyboard: r - This will reset the flight controller board and make it enter DFU mode b - This will instruct the onboard SPI receiver to enter BIND mode This is a tool you probably won't need to use but I find it helpful when I'm developing (or debugging) a feature of SilverLite, it lets me perform simple printf() style logging from the flight controller that I can see on my terminal window within VSCode. To run the tool (be sure to have Python2 installed) and then run open a terminal window within VSCode and execute it. Enter something like: ./monitor.py Or maybe python monitor.py To quit the monitor script, you just need to enter Ctrl-C (maybe several times) and it will eventually terminate. You can also leave it running and plug/unplug your FC board. The monitor script will poll the available serial ports on your computer until it senses you've plugged the flight controller back in. A more in-depth description on how to build and flash manually This project uses make to build and optionally flash the firmware. On Mac OS you may (or may not) already have make installed. I had it on my Macs because I have Xcode installed on them (along with the command line tools). On my Windows 10 machine I had to install MinGW-W64 which installs mingw32-make.exe ; that is the name of the make tool that I use on Windows. Whether on Mac or on Windows you'll want a terminal (or CMD prompt) window to run and execute the make program. I typically use a \"Terminal\" window within Visual Studio. You can set that up to use the Windows CMD.exe program but I prefer a bash command prompt. On my Windows PC I have git for windows installed which also installs a bash shell. Both work fine. I enter the following command in that terminal to build. mingw32-make.exe -j12 Or on Mac or Linux you would type: make -j12 Note: The -j12 instructs the make tool ( mingw32-make.exe ) to use twelve jobs (threads) when compiling; this speeds up the build process substantially. This will build the default make target named all (look towards the bottom of the Makefile ). If you examine the Makefile you'll see that it will build the NOX flight controller target (due to the TARGET definition at the top of the file) and this will result in the following files being generated: NOX.bin NOX.elf NOX.hex These will be found in the gcc_release/NOX folder. Any of these files can be used to flash the firmware onto a flight controller board. Which one to use depends on the flashing tool/software you wish to use. The Makefile has several make targets that can be used to flash (or build then flash) the firmware using different tools/software. More on that later. Specifying a Flight Controller Target Because I did not specify a target with the earlier command line, the firmware will be built for the (default) NOX flight controller target. See the Targets document for details regarding the targets supported by SilverLite. You can build the OMNIBUSF4 target by specifying it like so: mingw32-make.exe -j12 TARGET=OMNIBUSF4 If you're developing code and make changes and would like to clean up all intermediate object files (so you end up with a full rebuild) you can use the clean command like so: mingw32-make.exe clean Note: When using clean make sure you specify the target if it isn't the default NOX target. Build and Flash To flash the firmware onto a flight controller you will need to have it connected via USB or via an ST-Link adapter. The OMNIBUSF4 flight controller board (that I use) has breakout pads for the SWDIO and SWCLK pins of the STM32. This lets me use an ST-Link adapter which gives me the added ability to debug code in addition to flashing it. If you examine the Makefile and look for the flash target you will see that it uses openocd to flash the firmware when your build target is OMNIBUSF4 . If your build target is NOX , the makefile will instead use the command line version of STM32CubeProgrammer to flash the firmware. Note: The flash target in the makefile will build and flash Enter the following command line to flash (and build if necessary) the default NOX target: mingw32-make.exe -j12 flash Or make -j12 flash Note: To flash the OMNIBUSF4 target you must add TARGET=OMNIBUSF4 to the command line The NOX flight controller boards that I've been using (the \"JMT Play F4\" also known as \"JHEMCU Play F4\") does not have the SWDIO and SWCLK pins exposed. This means I must reset the board into DFU (bootloader) mode and connect it to my PC via USB. There are 2 boot pads on the top side near the front corner (look for \"BOOT\" as shown in this pic): Short those two boot pads together while powering up the board (either by connecting it to your PC via USB or by connecting a battery to the board). I find this to be rather tricky to do so I've added a feature to the firmware that lets you easily enter bootloader mode with a simple utility program. So after the first successful flashing of the firmware you won't have to use those boot pads again. More on this in the \"Monitor\" section of this document. Another method you can use to enter DFU mode is to use the \"L-R-D\" gesture (Left/Right/Down). But this (of course) means you need to have successfully flashed the firmware once already and are able to connect your TX to the flight controller. Note: If you have an OMNIBUSF4 target and don't wish to use an ST-Link adapter then edit the Makefile so that it uses the STM32CubeProgrammer to build and flash the firmware. My OMNIBUSF4 flight controller board actually has a handy pushbutton to enter DFU mode. Alternatively you can build first (using the all target) and then use one of the flash targets described next. Flash only Assuming you've built the firmware already you have your choice of two makefile targets stlinkflash - This will use OpenOCD to flash the firmware using an ST-Link adapter download - This will use STMCubeProgrammer to flash the firmware over USB Monitor The monitor.py script (found in the project root folder) can be used to monitor the output of the firmware via USB connection to your PC. Note: The monitor.py script requires you have the PySerial python module. Use pip install PySerial in case you don't already have it. If you've successfully flashed the firmware you can use a simple utility program written in Python to monitor the debug output of the firmware. Connect your board via USB to your PC. Invoke this script like so: ./monitor.py Or like so: python monitor.py I usually open another \"terminal\" pane in Visual Studio for this. The output will look something like this: Flight controller found on COM23 looptime: 81 osdTime: 43 pps: 0 hit: 0 hcrc: 0 bcrc: 0 looptime: 88 osdTime: 56 pps: 0 hit: 0 hcrc: 0 bcrc: 0 looptime: 83 osdTime: 43 pps: 0 hit: 0 hcrc: 0 bcrc: 0 The \"looptime\" stuff repeats like every second or so. The firmware has a few lines of code that emit log statements that this monitor.py script can echo to your screen. These values were helpful to me when I was developing the firmware. These will probably be removed but for now I'll document them here: \"looptime\" This is the time (in microseconds) for the longest loop within the past second. The firmware runs 4000 loop iterations per second. \"osdtime\" This is how long it took (in microseconds) to update the OSD. As you can see it is pretty expensive (I'm using a software SPI implementation) \"pps\" The number of packets successfully received and accepted per second. \"hit\" The number of packets received but not necessarily accepted per second \"hcrc\" The number of packet CRC failures (as detected by hardware) \"bcrc\" The number of bayang packet Checksum failures (as detected by software) Note: If hardware CRC checking is available then Bayang checksum failures will never occur (as the hardware CRC check will reject the packet before the Bayang checksum would occur) Use Ctrl-C in the terminal window to kill the monitor program. If it doesn't close right away you may need to use Ctrl-C repeatedly until it finally does. If you disconnect the flight controller the monitor program will continue to run and keep trying to re-connect to the flight controller. Plugging the controller back in will usually establish a reconnect with the monitor tool. Note: This monitor.py script might not work under Linux. I've used it on Windows 10 and Mac OS, however when trying to use it with Ubuntu running in Windows Subsystem for Linux it was not able to connect. Using the monitor to enter DFU (bootloader) mode While the monitor tool is connected and running you can press your r key on your keyboard to reset the board into DFU mode. The terminal should display the following when you do this: Sending reset command You will also see in the windows Device Manager tool that the Virtual COM port has disappeared and a new \"STM32 BOOTLOADER\" device appears under the \"Universal Serial Bus devices\" section. You can now flash new firmware to your board. Use the make tool and flash or download targets, or you can use the STM32CubeProgrammer tool.","title":"Build and Flash"},{"location":"Develop/#building","text":"Before you can run this firmware onto your flight controller you will need to build it and then flash it onto your board.","title":"Building"},{"location":"Develop/#the-easy-way-to-build-and-flash","text":"Use Visual Studio Code as a lightweight development environment. Make sure you've setup the necesary development tools (see the Development Tools Section ). Use the VSCode \"Open Folder\" option with the project folder you cloned from github. I've configured some files (within the .vs folder) to define some \"tasks\" that make it much easier to build and flash. You can click on the \"Run build task\" icon in the status bar... ..or use the Ctrl-Alt-T keyboard combination to bring up the following menu which will let you clean, build and flash for any of the supported targets:","title":"The easy way to build and flash"},{"location":"Develop/#enter-dfu-mode","text":"Before you can flash the firmware the flight controller board must enter DFU mode. Typically you would press a \"BOOT\" button on the FC board (or jump some BOOT pads together) and then power up the flight controller board by plugging in the USB cable. You could also power it up with a battery, but you'll still need to connect the board to your compute via USB. If your board is currently running Betaflight and you can connect to it with the Betaflight configurator, you could instead use the \"CLI\" option in Betaflight and enter bl in the command line to enter \"bootloader\" mode (DFU mode). Once you've entered DFU mode you should be able to flash SilverLite onto your FC board.","title":"Enter DFU mode"},{"location":"Develop/#the-monitorpy-script","text":"This is a handly little Python script I knocked out that listens over the virtual com port (the USB connection). SilverLite periodically sends out a data packet every second that this script can decode and log onto the terminal window. However it can also be used to enter commands by pressing a key on your keyboard: r - This will reset the flight controller board and make it enter DFU mode b - This will instruct the onboard SPI receiver to enter BIND mode This is a tool you probably won't need to use but I find it helpful when I'm developing (or debugging) a feature of SilverLite, it lets me perform simple printf() style logging from the flight controller that I can see on my terminal window within VSCode. To run the tool (be sure to have Python2 installed) and then run open a terminal window within VSCode and execute it. Enter something like: ./monitor.py Or maybe python monitor.py To quit the monitor script, you just need to enter Ctrl-C (maybe several times) and it will eventually terminate. You can also leave it running and plug/unplug your FC board. The monitor script will poll the available serial ports on your computer until it senses you've plugged the flight controller back in.","title":"The monitor.py script"},{"location":"Develop/#a-more-in-depth-description-on-how-to-build-and-flash-manually","text":"This project uses make to build and optionally flash the firmware. On Mac OS you may (or may not) already have make installed. I had it on my Macs because I have Xcode installed on them (along with the command line tools). On my Windows 10 machine I had to install MinGW-W64 which installs mingw32-make.exe ; that is the name of the make tool that I use on Windows. Whether on Mac or on Windows you'll want a terminal (or CMD prompt) window to run and execute the make program. I typically use a \"Terminal\" window within Visual Studio. You can set that up to use the Windows CMD.exe program but I prefer a bash command prompt. On my Windows PC I have git for windows installed which also installs a bash shell. Both work fine. I enter the following command in that terminal to build. mingw32-make.exe -j12 Or on Mac or Linux you would type: make -j12 Note: The -j12 instructs the make tool ( mingw32-make.exe ) to use twelve jobs (threads) when compiling; this speeds up the build process substantially. This will build the default make target named all (look towards the bottom of the Makefile ). If you examine the Makefile you'll see that it will build the NOX flight controller target (due to the TARGET definition at the top of the file) and this will result in the following files being generated: NOX.bin NOX.elf NOX.hex These will be found in the gcc_release/NOX folder. Any of these files can be used to flash the firmware onto a flight controller board. Which one to use depends on the flashing tool/software you wish to use. The Makefile has several make targets that can be used to flash (or build then flash) the firmware using different tools/software. More on that later.","title":"A more in-depth description on how to build and flash manually"},{"location":"Develop/#specifying-a-flight-controller-target","text":"Because I did not specify a target with the earlier command line, the firmware will be built for the (default) NOX flight controller target. See the Targets document for details regarding the targets supported by SilverLite. You can build the OMNIBUSF4 target by specifying it like so: mingw32-make.exe -j12 TARGET=OMNIBUSF4 If you're developing code and make changes and would like to clean up all intermediate object files (so you end up with a full rebuild) you can use the clean command like so: mingw32-make.exe clean Note: When using clean make sure you specify the target if it isn't the default NOX target.","title":"Specifying a Flight Controller Target"},{"location":"Develop/#build-and-flash","text":"To flash the firmware onto a flight controller you will need to have it connected via USB or via an ST-Link adapter. The OMNIBUSF4 flight controller board (that I use) has breakout pads for the SWDIO and SWCLK pins of the STM32. This lets me use an ST-Link adapter which gives me the added ability to debug code in addition to flashing it. If you examine the Makefile and look for the flash target you will see that it uses openocd to flash the firmware when your build target is OMNIBUSF4 . If your build target is NOX , the makefile will instead use the command line version of STM32CubeProgrammer to flash the firmware. Note: The flash target in the makefile will build and flash Enter the following command line to flash (and build if necessary) the default NOX target: mingw32-make.exe -j12 flash Or make -j12 flash Note: To flash the OMNIBUSF4 target you must add TARGET=OMNIBUSF4 to the command line The NOX flight controller boards that I've been using (the \"JMT Play F4\" also known as \"JHEMCU Play F4\") does not have the SWDIO and SWCLK pins exposed. This means I must reset the board into DFU (bootloader) mode and connect it to my PC via USB. There are 2 boot pads on the top side near the front corner (look for \"BOOT\" as shown in this pic): Short those two boot pads together while powering up the board (either by connecting it to your PC via USB or by connecting a battery to the board). I find this to be rather tricky to do so I've added a feature to the firmware that lets you easily enter bootloader mode with a simple utility program. So after the first successful flashing of the firmware you won't have to use those boot pads again. More on this in the \"Monitor\" section of this document. Another method you can use to enter DFU mode is to use the \"L-R-D\" gesture (Left/Right/Down). But this (of course) means you need to have successfully flashed the firmware once already and are able to connect your TX to the flight controller. Note: If you have an OMNIBUSF4 target and don't wish to use an ST-Link adapter then edit the Makefile so that it uses the STM32CubeProgrammer to build and flash the firmware. My OMNIBUSF4 flight controller board actually has a handy pushbutton to enter DFU mode. Alternatively you can build first (using the all target) and then use one of the flash targets described next.","title":"Build and Flash"},{"location":"Develop/#flash-only","text":"Assuming you've built the firmware already you have your choice of two makefile targets stlinkflash - This will use OpenOCD to flash the firmware using an ST-Link adapter download - This will use STMCubeProgrammer to flash the firmware over USB","title":"Flash only"},{"location":"Develop/#monitor","text":"The monitor.py script (found in the project root folder) can be used to monitor the output of the firmware via USB connection to your PC. Note: The monitor.py script requires you have the PySerial python module. Use pip install PySerial in case you don't already have it. If you've successfully flashed the firmware you can use a simple utility program written in Python to monitor the debug output of the firmware. Connect your board via USB to your PC. Invoke this script like so: ./monitor.py Or like so: python monitor.py I usually open another \"terminal\" pane in Visual Studio for this. The output will look something like this: Flight controller found on COM23 looptime: 81 osdTime: 43 pps: 0 hit: 0 hcrc: 0 bcrc: 0 looptime: 88 osdTime: 56 pps: 0 hit: 0 hcrc: 0 bcrc: 0 looptime: 83 osdTime: 43 pps: 0 hit: 0 hcrc: 0 bcrc: 0 The \"looptime\" stuff repeats like every second or so. The firmware has a few lines of code that emit log statements that this monitor.py script can echo to your screen. These values were helpful to me when I was developing the firmware. These will probably be removed but for now I'll document them here: \"looptime\" This is the time (in microseconds) for the longest loop within the past second. The firmware runs 4000 loop iterations per second. \"osdtime\" This is how long it took (in microseconds) to update the OSD. As you can see it is pretty expensive (I'm using a software SPI implementation) \"pps\" The number of packets successfully received and accepted per second. \"hit\" The number of packets received but not necessarily accepted per second \"hcrc\" The number of packet CRC failures (as detected by hardware) \"bcrc\" The number of bayang packet Checksum failures (as detected by software) Note: If hardware CRC checking is available then Bayang checksum failures will never occur (as the hardware CRC check will reject the packet before the Bayang checksum would occur) Use Ctrl-C in the terminal window to kill the monitor program. If it doesn't close right away you may need to use Ctrl-C repeatedly until it finally does. If you disconnect the flight controller the monitor program will continue to run and keep trying to re-connect to the flight controller. Plugging the controller back in will usually establish a reconnect with the monitor tool. Note: This monitor.py script might not work under Linux. I've used it on Windows 10 and Mac OS, however when trying to use it with Ubuntu running in Windows Subsystem for Linux it was not able to connect.","title":"Monitor"},{"location":"Develop/#using-the-monitor-to-enter-dfu-bootloader-mode","text":"While the monitor tool is connected and running you can press your r key on your keyboard to reset the board into DFU mode. The terminal should display the following when you do this: Sending reset command You will also see in the windows Device Manager tool that the Virtual COM port has disappeared and a new \"STM32 BOOTLOADER\" device appears under the \"Universal Serial Bus devices\" section. You can now flash new firmware to your board. Use the make tool and flash or download targets, or you can use the STM32CubeProgrammer tool.","title":"Using the monitor to enter DFU (bootloader) mode"},{"location":"FlySky/","text":"These are notes on FlySky AFHDS and AFHDS2A protocol Pascal's DIY Multiprotocol module has an RX implementation. See: Multiprotocol\\AFHDS2A_Rx_a7105.ino Betaflight rx code is here: src\\main\\rx\\a7105_flysky.c A7105-receiver/uFlySky, based off of Betaflight/Cleanflight code: https://github.com/nikdavis/A7105-receiver/tree/master/uFlSky Betaflight uses an interrupt pin from the A7105 module, while MPM doesn't seem to and instead reads A7105_00_MODE register uFlySky seems to be a better starting point than Betaflight as it has stripped out many of the Betaflight baggage.","title":"These are notes on FlySky AFHDS and AFHDS2A protocol"},{"location":"FlySky/#these-are-notes-on-flysky-afhds-and-afhds2a-protocol","text":"Pascal's DIY Multiprotocol module has an RX implementation. See: Multiprotocol\\AFHDS2A_Rx_a7105.ino Betaflight rx code is here: src\\main\\rx\\a7105_flysky.c A7105-receiver/uFlySky, based off of Betaflight/Cleanflight code: https://github.com/nikdavis/A7105-receiver/tree/master/uFlSky Betaflight uses an interrupt pin from the A7105 module, while MPM doesn't seem to and instead reads A7105_00_MODE register uFlySky seems to be a better starting point than Betaflight as it has stripped out many of the Betaflight baggage.","title":"These are notes on FlySky AFHDS and AFHDS2A protocol"},{"location":"OMNIBUS vs NOX SilF4ware diffs/","text":"OMNIBUSF4 vs NOX SilF4ware diffs C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Inc\\main.h GPIO pin defines C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Inc\\stm32f4xx_it.h DMA stream used OMNIBUSF4 void DMA1_Stream4_IRQHandler(void); NOX void DMA1_Stream6_IRQHandler(void); C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Src\\blackbox.c OMNIBUSF4 extern void MX_UART4_Init( void ); MX_UART4_Init(); extern UART_HandleTypeDef huart4; // HAL_UART_IRQHandler( huart4 ); // Resets huart- gState to HAL_UART_STATE_READY huart4.gState = HAL_UART_STATE_READY; // Do it directly to save flash space. HAL_UART_Transmit_DMA( huart4, bb_buffer, sizeof( bb_buffer ) ); NOX extern void MX_USART2_UART_Init( void ); MX_USART2_UART_Init(); extern UART_HandleTypeDef huart2; // HAL_UART_IRQHandler( huart2 ); // Resets huart- gState to HAL_UART_STATE_READY huart2.gState = HAL_UART_STATE_READY; // Do it directly to save flash space. HAL_UART_Transmit_DMA( huart2, bb_buffer, sizeof( bb_buffer ) ); C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Src\\config.h OMNIBUSF4 #define SENSOR_ROTATE_90_CCW NOX #define SENSOR_ROTATE_180 C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Src\\main.c Many changes regarding * UART/USART used (for blackbox logging) OMNIBUSF4 - UART4 NOX - USART2 * Clock config OMNIBUSF4 - 168Mhz NOX - 100 Mhz....but I need to change this to 96Mhz for USB VCP * ADC channel OMNIBUSF4 12 NOX 5 * TIM2 OMNIBUSF4 Prescaler set to 84 NOX Prescaler set to 100 , but I'll need to change this to 96 due to clock config change * DMA set IRQ priority and enables IRQ OMNIBUSF4 Uses DMA1_Stream4 OMNIBUSF4 Uses DMA1_Stream6 * GPIO setup C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Src\\stm32f4xx_hal_msp.c MSP - MCU Specific Package This is the processor (and peripheral/resource) specific initialization code C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Core\\Src\\stm32f4xx_it.c These are the interrupt service routines Drivers folder... OMNIBUSF4 has this file C:\\Projects\\Hobbies\\RC\\STM32F405-Omnibus\\Drivers\\CMSIS\\Device\\ST\\STM32F4xx\\Include\\stm32f405xx.h NOX has this file C:\\Projects\\Hobbies\\RC\\STM32F411-NOXE\\Drivers\\CMSIS\\Device\\ST\\STM32F4xx\\Include\\stm32f411xe.h Core/Inc/ main.h stm32f4xx_it.h","title":"OMNIBUS vs NOX SilF4ware diffs"},{"location":"PlayF4_NRF24L01/","text":"This describes how I use a \"Play F4\" whoop sized flight controller board with an NRF24L01 micro transceiver board. The interface between the STM32 microcontroller and the NRF24L01 transceiver board is via software SPI. This consists of the following control signals: MOSI (master out slave in) MISO (master in slave out) CS or CSN (chip Select NOT where active LOW signal means chip is selected) SCK (serial clock) You can see why this is sometimes called 4-wire SPI. The XN297(L) sometimes comes in a 3-wire version where MISO and MOSI are run on a single wire as the XN297 (slave) will never output at the same time that STM32 (master) is outputting. In addition to the 4 signal wires we also need power (3.3 volts) and ground wire leads. That's a total of 6 wires needed to interface the NRF24L01 to the Play F4 flight controller board. Top side of the Play F4 board The 3.3v power and ground pads are readily available. The remaining pads that we can repurpose for our own use are: TX1 - Labeled T1 on the board. This is TX of USART1 (PB6) DSM/IBUS/PPM - Labeled RX2 on the board but please note that it really isn't an RX pin of a UART/USART (PB10) SBUS - This connects to a configurable logic inverter (enabled/disabled by PC14) before going to RX of USART2 (PA3) Bottom side of the board RX1 - Labeled R1 on the board. Goes directly to PB7 (verified with multimeter) (USART1 RX) TX2 - Labeled T2 on the board. Goes directly to PA2 (verified with multimeter) (USART2 TX) LED_STRIP - Labeled LED on the board. Goes directly to PA0 (verified with multimeter) BZ- - Labeled BZ- on the board. Does not seem to be directly tied to STM32, probably uses a driver transistor to PC13 All of the pads that are directly tied to the STM32 processor can be used to connect the NRF24L01. This is because the input/output pins of the STM32 are easily configurable. Let me re-list the port pins we can use: PA0 LED_STRIP PA2 TX2 PB6 TX1 PB7 RX1 PB10 DSM/IBUS/PPM Most any pin of the STM32 can be configured for either input or output. This makes it easy for us to use any of those pads for any SPI signal. The header file trx_spi_config.h is where you perform this configuration. Here is a copy/paste of the default configuration I use: static Pin 'A', 2 TRX_CS_PIN; // PA2 TX2 static Pin 'A', 0 SPI_SCK; // PA0 LED_STRIP static Pin 'B', 6 SPI_MOSI; // PB6 TX1 static Pin 'B', 10 SPI_MISO; // PB10 DSM/IBUS/PPM Here you can see pin PA2 is assigned to the CS signal, PA0 is assigned to SCK signal, and so on. This is the wiring method that works for me when I mount the NRF24L01 micro board on top front side of the flight controller board. Only two of the wires have to reach around to the bottom side, and those FC pads are actually very close to the corresponding NRF24L01 pads since I oriented the NRF24L01 to have its pads to the left (as shown in the pic). Note: You'll notice that I removed the onboard PCB antenna (I simply snapped it off) and replaced it with a length of enamel wire. Below is a different orientation where I had the transceiver module on the bottom side of the flight controller board (as used on the black micro shown at the top of this page): Note: Here you can see I'm using the built-in PCB antenna. If you look at the black GR1FF Race micro at the top of this page you'll also be able to see the antenna I chose to use the RX1 pad on the bottom side for CS static Pin 'B', 7 TRX_CS_PIN; // PB7 RX1 static Pin 'A', 0 SPI_SCK; // PA0 LED_STRIP static Pin 'B', 6 SPI_MOSI; // PB6 TX1 static Pin 'B', 10 SPI_MISO; // PB10 DSM/IBUS/PPM Defining the pins As you've probably noticed, the Pin template takes an uppercase character (like 'A', 'B', etc) to specify which STM32 port the pin is on and the second parameter is the pin number. It's that simple. No need to use STM32CubeMX , just edit SilverLite\\trx_spi_config.h . Don't do the following! Please be very careful with how you wire the board. The above picture shows an orientation (where the NRF24L01 was rotated 90degrees so that the module's pins were facing towards the bottom corner). You'll see that several wires are very close to the black squarish component which is an inductor (with 100 printed on it). This led to a significant amount of electrical/rf noise traveling to the module and pretty much prevented any reception!","title":"Play F4 and NRF24L01"},{"location":"PlayF4_NRF24L01/#top-side-of-the-play-f4-board","text":"The 3.3v power and ground pads are readily available. The remaining pads that we can repurpose for our own use are: TX1 - Labeled T1 on the board. This is TX of USART1 (PB6) DSM/IBUS/PPM - Labeled RX2 on the board but please note that it really isn't an RX pin of a UART/USART (PB10) SBUS - This connects to a configurable logic inverter (enabled/disabled by PC14) before going to RX of USART2 (PA3)","title":"Top side of the Play F4 board"},{"location":"PlayF4_NRF24L01/#bottom-side-of-the-board","text":"RX1 - Labeled R1 on the board. Goes directly to PB7 (verified with multimeter) (USART1 RX) TX2 - Labeled T2 on the board. Goes directly to PA2 (verified with multimeter) (USART2 TX) LED_STRIP - Labeled LED on the board. Goes directly to PA0 (verified with multimeter) BZ- - Labeled BZ- on the board. Does not seem to be directly tied to STM32, probably uses a driver transistor to PC13 All of the pads that are directly tied to the STM32 processor can be used to connect the NRF24L01. This is because the input/output pins of the STM32 are easily configurable. Let me re-list the port pins we can use: PA0 LED_STRIP PA2 TX2 PB6 TX1 PB7 RX1 PB10 DSM/IBUS/PPM Most any pin of the STM32 can be configured for either input or output. This makes it easy for us to use any of those pads for any SPI signal. The header file trx_spi_config.h is where you perform this configuration. Here is a copy/paste of the default configuration I use: static Pin 'A', 2 TRX_CS_PIN; // PA2 TX2 static Pin 'A', 0 SPI_SCK; // PA0 LED_STRIP static Pin 'B', 6 SPI_MOSI; // PB6 TX1 static Pin 'B', 10 SPI_MISO; // PB10 DSM/IBUS/PPM Here you can see pin PA2 is assigned to the CS signal, PA0 is assigned to SCK signal, and so on. This is the wiring method that works for me when I mount the NRF24L01 micro board on top front side of the flight controller board. Only two of the wires have to reach around to the bottom side, and those FC pads are actually very close to the corresponding NRF24L01 pads since I oriented the NRF24L01 to have its pads to the left (as shown in the pic). Note: You'll notice that I removed the onboard PCB antenna (I simply snapped it off) and replaced it with a length of enamel wire. Below is a different orientation where I had the transceiver module on the bottom side of the flight controller board (as used on the black micro shown at the top of this page): Note: Here you can see I'm using the built-in PCB antenna. If you look at the black GR1FF Race micro at the top of this page you'll also be able to see the antenna I chose to use the RX1 pad on the bottom side for CS static Pin 'B', 7 TRX_CS_PIN; // PB7 RX1 static Pin 'A', 0 SPI_SCK; // PA0 LED_STRIP static Pin 'B', 6 SPI_MOSI; // PB6 TX1 static Pin 'B', 10 SPI_MISO; // PB10 DSM/IBUS/PPM","title":"Bottom side of the board"},{"location":"PlayF4_NRF24L01/#defining-the-pins","text":"As you've probably noticed, the Pin template takes an uppercase character (like 'A', 'B', etc) to specify which STM32 port the pin is on and the second parameter is the pin number. It's that simple. No need to use STM32CubeMX , just edit SilverLite\\trx_spi_config.h .","title":"Defining the pins"},{"location":"PlayF4_NRF24L01/#dont-do-the-following","text":"Please be very careful with how you wire the board. The above picture shows an orientation (where the NRF24L01 was rotated 90degrees so that the module's pins were facing towards the bottom corner). You'll see that several wires are very close to the black squarish component which is an inductor (with 100 printed on it). This led to a significant amount of electrical/rf noise traveling to the module and pretty much prevented any reception!","title":"Don't do the following!"},{"location":"STM32-Resources/","text":"SystemClock ADC1 - Battery voltage TIM1 NOX TIM1_UP: DMA2, Stream 5, NVIC global interrupt enabled TIM1_CH: DMA2, Stream 1, NVIC global interrupt enabled TIM1_CH2: DMA2, Stream 2, NVIC global interrupt enabled OMNIBUSF4 TIM1_UP: DMA2, Stream 5, NVIC global interrupt enabled TIM1_CH: DMA2, Stream 1, NVIC global interrupt enabled TIM1_CH2: DMA2, Stream 2, NVIC global interrupt enabled TIM2 for gettime() Blackbox NOX: USART2, 2MB, 8N1 USART2_TX: DMA1, Stream 6 OMNIBUSF4: UART4, 2MB, 8N1 UART4_TX: DMA1, Stream 4 DSHOT (drv_dshot_bdir and drv_dshot_dma) uses TIM1, DMA2","title":"STM32 Resources"},{"location":"Targets/","text":"Flight Controller Targets This codebase currently supports several targets using the STM32F411 or STM32405 processors. A target is simply the name of a hardware configuration (processor and peripherals) that was defined for use with Betaflight. Different flight controller boards can be made that correspond to a given target. The target names I'm using come straight from Betaflight. By examining various source files in Betaflight I'm able to reverse engineer what peripherals are used on the flight controller boards and also what pins are used. The following flight controller targets are currently defined: OMNIBUSF4 - This uses the STM32F405 processor which runs at 168Mhz NOX - This uses the STM32F411 processor which runs at 98Mhz or 100Mhz (we must use 98Mhz for proper USB Virtual Com Port support) MATEKF411RX - This uses the STM32F411 processor. At this time only the \"HappyModel Crazybee F4 Lite 1S FlySky\" flight controller is currently supported. I had also planned on supporting the CrazyBee F3 flight controller but have yet to do so. Note: The Makefile defaults to building for the NOX target but this can be overriden when invoking the makefile by specifying the TARGET on the command line like so: mingw32-make.exe -j12 flash TARGET=OMNIBUSF4 The above command will build the OMNIBUSF4 target and flash the build onto the flight controller board. For more details on how to build and flash (and develop) this software read the Develop page If using Visual Studio Code then you can click on the \"Run build task\" icon in the status bar... ..or use the Ctrl-Alt-T combination to bring up this menu which will let you clean, build and flash for any of the supported targets: MATEKF411RX The \"HappyModel Crazybee F4 Lite 1S FlySky\" flight controller is a MATEKF411RX target board. This board is used on the Mobula 6. This flight controller (and target) also supports an FrSky SPI receiver as well. However I only possess the FlySky version and therefore only built support for the AFHDS/AFHDS2A receiver. This is the easiest board to use with SilverLite-FC. NOX I've been using the \"Play F4\" flight controller (sometimes described as \"JHEMCU Play F4\" or \"JMT Play F4\"). This board is a NOX target. This is what it looks like: By examining the Betaflight source code and target.h files for this Betaflight target (as well as using the resource and resource list commands) we can learn how the STM32 processor interfaces with the MPU, OSD and other peripherals. For example, the following pads of the Play F4 board map to the STM32 pins: On top side of board are: 3.3v DSM/IBUS/PPM - Goes directly to PB10 (verified with multimeter) SBUS - Coupled thru a switchable inverter (controlled by PC14) and then (I think) to PA3 (USART2 RX) 5v GND TX1 - Goes directly to PB6 (USART1 TX) On back (bottom) side of board are: RX1 - Goes directly to PB7 (verified with multimeter) (USART1 RX) TX2 - Goes directly to PA2 (verified with multimeter) (USART2 TX) LED_STRIP - Goes directly to PA0 (verified with multimeter) BZ- - Does not seem to be directly tied to STM32, probably uses a driver transistor to PC13 This information is important if you want to change which pads to use to interface to your transceiver board (NRF24L01, XN297, XN297L or LT8900). More information can be found in the Transceiver Modules section. Adding support for new targets This section will contain my notes on what is required to add support for new targets. The notes are largely based on what I performed for adding the MATEKF411RX target. The project folder structure contains a Targets folder that in turn contains subfolders for each of the targets (such as NOX , OMNIBUSF4 ). In turn these folders contain the following: TARGET_NAME.ioc - This is an STM32CubeMX project file used to configure the STM32 and its peripherals.. The TARGET_NAME will be something like NOX or OMNIBUS , etc. Core - STM32CubeMX generated source files I want to add support for the Mobula6 flight controller which is the \"HappyModel Crazybee F4 Lite 1S\" board. In Betaflight it is known as the MATEKF411RX target. So I would create a new folder with that name within our Targets folder. Using STM32CubeMX you'll want to configure the various pins and perhipherals of the STM32 chip. Required by Silverware: SPI interface for the MPU (4-wire soft spi implementation) SPI_MPU_SS - PA4 (GPIO output) SPI2_CLK - PA5 (GPIO output) SPI2_MISO - PA6 (GPIO input) SPI2_MOSI - PA7 (GPIO output) SPI interface for the OSD This is actually configured by editing drv_sd_spi.config.h rather than via Stm32CubeMX SWD pins (SWDIO, SWCLK) - If available SWD is not available on MATEKF411RX , in fact PA14 and/or PA13 are used for other purposes ESC1 - PB10 (GPIO output) ESC2 - PB6 (GPIO output) ESC3 - PB7 (GPIO output) ESC4 - PB8 (GPIO output) VOLTAGE_DIVIDER - PB0 (ADC input) LED - PC13 (GPIO output) Additional/Available on this FC board CURRENT_METER_ADC_PIN - PB1 (ADC) RX SPI (FlySky A7105) * SPI3_SCK_PIN - PB3 (GPIO output) * SPI3_MISO_PIN - PB4 (GPIO input) * SPI3_MOSI_PIN - PB5 (GPIO output) * RX_NSS_PIN - PA15 (GPIO output) * RX_SPI_EXTI_PIN - PA14 (GPIO External interrupt mode) * Examining A7105Init() in Betaflight source code reveals it is configured for EXTI_TRIGGER_RISING * RX_SPI_LED_PIN - PB9 (GPIO output) * RX_SPI_BIND_PIN - PB2 (GPIO input), Should we enable pull up or pull down? After completing support for this target I discovered it did not need any pull up or pull down. Note: For ESC pinouts look inside Betaflight for the corresponding target.c and you'll see a table like this: const timerHardware_t timerHardware[USABLE_TIMER_CHANNEL_COUNT] = { DEF_TIM(TIM9, CH2, PA3, TIM_USE_PPM, 0, 0), // PPM/RX2 DEF_TIM(TIM2, CH3, PB10, TIM_USE_MOTOR, 0, 0), // S1_OUT - DMA1_ST1 DEF_TIM(TIM4, CH1, PB6, TIM_USE_MOTOR, 0, 0), // S2_OUT - DMA1_ST0 DEF_TIM(TIM4, CH2, PB7, TIM_USE_MOTOR, 0, 0), // S3_OUT - DMA1_ST3 DEF_TIM(TIM4, CH3, PB8, TIM_USE_MOTOR, 0, 0), // S4_OUT - DMA1_ST7 DEF_TIM(TIM5, CH1, PA0, TIM_USE_LED, 0, 0), // 2812LED - DMA1_ST2 DEF_TIM(TIM9, CH1, PA2, TIM_USE_PWM, 0, 0 ), // TX2 DEF_TIM(TIM1, CH2, PA9, TIM_USE_PWM, 0, 0 ), // TX1 DEF_TIM(TIM1, CH3, PA10, TIM_USE_PWM, 0, 0 ), // RX1 }; This describes the timer peripherals used on the STM32 and you'll notice that 4 entries are tagged with TIM_USE_MOTOR ; these are the ESC pins in order from ESC1 thru ESC4. STM32 resources These are just some notes on various STM32 resources used by the firmware. SystemClock ADC1 - Battery voltage TIM1 and DMA2 are used for implementing DSHOT. TIM1_UP: DMA2, Stream 5, NVIC global interrupt enabled TIM1_CH: DMA2, Stream 1, NVIC global interrupt enabled TIM1_CH2: DMA2, Stream 2, NVIC global interrupt enabled TIM2 for gettime() If blackbox is enabled (default is disabled) the following are used: NOX: USART2_TX, 2MB, 8N1 DMA1, Stream 6 OMNIBUSF4 UART4_TX, 2MB, 8N1 DMA1, Stream 4","title":"Targets"},{"location":"Targets/#flight-controller-targets","text":"This codebase currently supports several targets using the STM32F411 or STM32405 processors. A target is simply the name of a hardware configuration (processor and peripherals) that was defined for use with Betaflight. Different flight controller boards can be made that correspond to a given target. The target names I'm using come straight from Betaflight. By examining various source files in Betaflight I'm able to reverse engineer what peripherals are used on the flight controller boards and also what pins are used. The following flight controller targets are currently defined: OMNIBUSF4 - This uses the STM32F405 processor which runs at 168Mhz NOX - This uses the STM32F411 processor which runs at 98Mhz or 100Mhz (we must use 98Mhz for proper USB Virtual Com Port support) MATEKF411RX - This uses the STM32F411 processor. At this time only the \"HappyModel Crazybee F4 Lite 1S FlySky\" flight controller is currently supported. I had also planned on supporting the CrazyBee F3 flight controller but have yet to do so. Note: The Makefile defaults to building for the NOX target but this can be overriden when invoking the makefile by specifying the TARGET on the command line like so: mingw32-make.exe -j12 flash TARGET=OMNIBUSF4 The above command will build the OMNIBUSF4 target and flash the build onto the flight controller board. For more details on how to build and flash (and develop) this software read the Develop page If using Visual Studio Code then you can click on the \"Run build task\" icon in the status bar... ..or use the Ctrl-Alt-T combination to bring up this menu which will let you clean, build and flash for any of the supported targets:","title":"Flight Controller Targets"},{"location":"Targets/#matekf411rx","text":"The \"HappyModel Crazybee F4 Lite 1S FlySky\" flight controller is a MATEKF411RX target board. This board is used on the Mobula 6. This flight controller (and target) also supports an FrSky SPI receiver as well. However I only possess the FlySky version and therefore only built support for the AFHDS/AFHDS2A receiver. This is the easiest board to use with SilverLite-FC.","title":"MATEKF411RX"},{"location":"Targets/#nox","text":"I've been using the \"Play F4\" flight controller (sometimes described as \"JHEMCU Play F4\" or \"JMT Play F4\"). This board is a NOX target. This is what it looks like: By examining the Betaflight source code and target.h files for this Betaflight target (as well as using the resource and resource list commands) we can learn how the STM32 processor interfaces with the MPU, OSD and other peripherals. For example, the following pads of the Play F4 board map to the STM32 pins: On top side of board are: 3.3v DSM/IBUS/PPM - Goes directly to PB10 (verified with multimeter) SBUS - Coupled thru a switchable inverter (controlled by PC14) and then (I think) to PA3 (USART2 RX) 5v GND TX1 - Goes directly to PB6 (USART1 TX) On back (bottom) side of board are: RX1 - Goes directly to PB7 (verified with multimeter) (USART1 RX) TX2 - Goes directly to PA2 (verified with multimeter) (USART2 TX) LED_STRIP - Goes directly to PA0 (verified with multimeter) BZ- - Does not seem to be directly tied to STM32, probably uses a driver transistor to PC13 This information is important if you want to change which pads to use to interface to your transceiver board (NRF24L01, XN297, XN297L or LT8900). More information can be found in the Transceiver Modules section.","title":"NOX"},{"location":"Targets/#adding-support-for-new-targets","text":"This section will contain my notes on what is required to add support for new targets. The notes are largely based on what I performed for adding the MATEKF411RX target. The project folder structure contains a Targets folder that in turn contains subfolders for each of the targets (such as NOX , OMNIBUSF4 ). In turn these folders contain the following: TARGET_NAME.ioc - This is an STM32CubeMX project file used to configure the STM32 and its peripherals.. The TARGET_NAME will be something like NOX or OMNIBUS , etc. Core - STM32CubeMX generated source files I want to add support for the Mobula6 flight controller which is the \"HappyModel Crazybee F4 Lite 1S\" board. In Betaflight it is known as the MATEKF411RX target. So I would create a new folder with that name within our Targets folder. Using STM32CubeMX you'll want to configure the various pins and perhipherals of the STM32 chip. Required by Silverware: SPI interface for the MPU (4-wire soft spi implementation) SPI_MPU_SS - PA4 (GPIO output) SPI2_CLK - PA5 (GPIO output) SPI2_MISO - PA6 (GPIO input) SPI2_MOSI - PA7 (GPIO output) SPI interface for the OSD This is actually configured by editing drv_sd_spi.config.h rather than via Stm32CubeMX SWD pins (SWDIO, SWCLK) - If available SWD is not available on MATEKF411RX , in fact PA14 and/or PA13 are used for other purposes ESC1 - PB10 (GPIO output) ESC2 - PB6 (GPIO output) ESC3 - PB7 (GPIO output) ESC4 - PB8 (GPIO output) VOLTAGE_DIVIDER - PB0 (ADC input) LED - PC13 (GPIO output) Additional/Available on this FC board CURRENT_METER_ADC_PIN - PB1 (ADC) RX SPI (FlySky A7105) * SPI3_SCK_PIN - PB3 (GPIO output) * SPI3_MISO_PIN - PB4 (GPIO input) * SPI3_MOSI_PIN - PB5 (GPIO output) * RX_NSS_PIN - PA15 (GPIO output) * RX_SPI_EXTI_PIN - PA14 (GPIO External interrupt mode) * Examining A7105Init() in Betaflight source code reveals it is configured for EXTI_TRIGGER_RISING * RX_SPI_LED_PIN - PB9 (GPIO output) * RX_SPI_BIND_PIN - PB2 (GPIO input), Should we enable pull up or pull down? After completing support for this target I discovered it did not need any pull up or pull down. Note: For ESC pinouts look inside Betaflight for the corresponding target.c and you'll see a table like this: const timerHardware_t timerHardware[USABLE_TIMER_CHANNEL_COUNT] = { DEF_TIM(TIM9, CH2, PA3, TIM_USE_PPM, 0, 0), // PPM/RX2 DEF_TIM(TIM2, CH3, PB10, TIM_USE_MOTOR, 0, 0), // S1_OUT - DMA1_ST1 DEF_TIM(TIM4, CH1, PB6, TIM_USE_MOTOR, 0, 0), // S2_OUT - DMA1_ST0 DEF_TIM(TIM4, CH2, PB7, TIM_USE_MOTOR, 0, 0), // S3_OUT - DMA1_ST3 DEF_TIM(TIM4, CH3, PB8, TIM_USE_MOTOR, 0, 0), // S4_OUT - DMA1_ST7 DEF_TIM(TIM5, CH1, PA0, TIM_USE_LED, 0, 0), // 2812LED - DMA1_ST2 DEF_TIM(TIM9, CH1, PA2, TIM_USE_PWM, 0, 0 ), // TX2 DEF_TIM(TIM1, CH2, PA9, TIM_USE_PWM, 0, 0 ), // TX1 DEF_TIM(TIM1, CH3, PA10, TIM_USE_PWM, 0, 0 ), // RX1 }; This describes the timer peripherals used on the STM32 and you'll notice that 4 entries are tagged with TIM_USE_MOTOR ; these are the ESC pins in order from ESC1 thru ESC4.","title":"Adding support for new targets"},{"location":"Targets/#stm32-resources","text":"These are just some notes on various STM32 resources used by the firmware. SystemClock ADC1 - Battery voltage TIM1 and DMA2 are used for implementing DSHOT. TIM1_UP: DMA2, Stream 5, NVIC global interrupt enabled TIM1_CH: DMA2, Stream 1, NVIC global interrupt enabled TIM1_CH2: DMA2, Stream 2, NVIC global interrupt enabled TIM2 for gettime() If blackbox is enabled (default is disabled) the following are used: NOX: USART2_TX, 2MB, 8N1 DMA1, Stream 6 OMNIBUSF4 UART4_TX, 2MB, 8N1 DMA1, Stream 4","title":"STM32 resources"},{"location":"Transceiver/","text":"TODO This is where I'll document how to install a transceiver board onto your flight controllers as well as how what adjustments you may need to perform to various configuration files (mostly header files). Using onboard SPI Currently only the FlySky version of the \"HappyModel Crazybee F4 Lite 1S\" flight controller (found on the Mobula6) us supported. Since this is built into the flight controller board the only thing you need to configure is whether you want to use the older AFHDS protocol (which has a minimal latency of 1.5ms) or the newer AFHDS2A protocol (minimal latency of 3.850ms). For external SPI RX modules Things to discuss: Describe the available choices of transceiver modules NRF24L01 Comes in different form factors The micro version like this one on Amazon works well. Many ebay, Aliexpress listings say they are NRF24L01 but are something completely different (not even a clone of the NRF24L01), so beware! With Play F4 board you must use capacitor across +3.3v and GND due to the noisy power supply. In comparison the XN297L seemed okay without a cap on the Play F4. XN297L Uses 3-wire SPI Easily harvested from H8mini transmitter LT8900 Requires an extra pin or a resister/capacitor combo to perform a reset on power-on. Requires a customized multiprotocol module firmware. I built a custom TX variant for this but never pushed this up to github. Need to edit _my_config.h to specify which transceiver module you're using. Just need to define only one of the following choices: TRX_NRF TRX_XN297 TRX_XN297L TRX_LT8900 Need to edit _my_config.h to specify if you'll be using 3-wire SPI or 4-wire SPI Enable the TRX_SPI_3WIRE for 3-wire, otherwise it will be 4-wire Need to edit trx_spi_config.h to specify which STM32 pins to use for the software SPI. The Play F4 and NRF24L01 section has more detail on this. Wiring considerations Avoid inductor coil Antenna mods","title":"Transceiver modules"},{"location":"Transceiver/#todo","text":"This is where I'll document how to install a transceiver board onto your flight controllers as well as how what adjustments you may need to perform to various configuration files (mostly header files).","title":"TODO"},{"location":"Transceiver/#using-onboard-spi","text":"Currently only the FlySky version of the \"HappyModel Crazybee F4 Lite 1S\" flight controller (found on the Mobula6) us supported. Since this is built into the flight controller board the only thing you need to configure is whether you want to use the older AFHDS protocol (which has a minimal latency of 1.5ms) or the newer AFHDS2A protocol (minimal latency of 3.850ms).","title":"Using onboard SPI"},{"location":"Transceiver/#for-external-spi-rx-modules","text":"Things to discuss: Describe the available choices of transceiver modules NRF24L01 Comes in different form factors The micro version like this one on Amazon works well. Many ebay, Aliexpress listings say they are NRF24L01 but are something completely different (not even a clone of the NRF24L01), so beware! With Play F4 board you must use capacitor across +3.3v and GND due to the noisy power supply. In comparison the XN297L seemed okay without a cap on the Play F4. XN297L Uses 3-wire SPI Easily harvested from H8mini transmitter LT8900 Requires an extra pin or a resister/capacitor combo to perform a reset on power-on. Requires a customized multiprotocol module firmware. I built a custom TX variant for this but never pushed this up to github. Need to edit _my_config.h to specify which transceiver module you're using. Just need to define only one of the following choices: TRX_NRF TRX_XN297 TRX_XN297L TRX_LT8900 Need to edit _my_config.h to specify if you'll be using 3-wire SPI or 4-wire SPI Enable the TRX_SPI_3WIRE for 3-wire, otherwise it will be 4-wire Need to edit trx_spi_config.h to specify which STM32 pins to use for the software SPI. The Play F4 and NRF24L01 section has more detail on this. Wiring considerations Avoid inductor coil Antenna mods","title":"For external SPI RX modules"}]}